diff --git a/gfx/cairo/cairo/src/cairo-quartz-surface.c b/gfx/cairo/cairo/src/cairo-quartz-surface.c
--- a/gfx/cairo/cairo/src/cairo-quartz-surface.c
+++ b/gfx/cairo/cairo/src/cairo-quartz-surface.c
@@ -33,6 +33,8 @@
  * Contributor(s):
  *	Vladimir Vukicevic <vladimir@mozilla.com>
  */
+
+#include <dlfcn.h>
 
 #include "cairoint.h"
 
@@ -100,11 +102,12 @@ CG_EXTERN CGImageRef CGBitmapContextCrea
 CG_EXTERN CGImageRef CGBitmapContextCreateImage (CGContextRef);
 #endif
 
-/* missing in 10.3.9 */
-extern void CGContextClipToMask (CGContextRef, CGRect, CGImageRef) __attribute__((weak_import));
+/* Only present in 10.4+ */
+static void (*CGContextClipToMaskPtr) (CGContextRef, CGRect, CGImageRef) = NULL;
+/* Only present in 10.5+ */
+static void (*CGContextDrawTiledImagePtr) (CGContextRef, CGRect, CGImageRef) = NULL;
 
-/* 10.5-only optimization */
-extern void CGContextDrawTiledImage (CGContextRef, CGRect, CGImageRef) __attribute__((weak_import));
+static cairo_bool_t _cairo_quartz_symbol_lookup_done = FALSE;
 
 /*
  * Utility functions
@@ -118,6 +121,18 @@ _cairo_quartz_surface_create_internal (C
 				       cairo_content_t content,
 				       unsigned int width,
 				       unsigned int height);
+
+/* Load all extra symbols */
+static void quartz_ensure_symbols()
+{
+    if (_cairo_quartz_symbol_lookup_done)
+	return;
+
+    CGContextClipToMaskPtr = dlsym(RTLD_DEFAULT, "CGContextClipToMask");
+    CGContextDrawTiledImagePtr = dlsym(RTLD_DEFAULT, "CGContextDrawTiledImage");
+
+    _cairo_quartz_symbol_lookup_done = TRUE;
+}
 
 /* CoreGraphics limitation with flipped CTM surfaces: height must be less than signed 16-bit max */
 
@@ -761,7 +776,7 @@ _cairo_quartz_setup_source (cairo_quartz
 	return _cairo_quartz_setup_radial_source (surface, rpat);
 
     } else if (source->type == CAIRO_PATTERN_TYPE_SURFACE &&
-	       (source->extend == CAIRO_EXTEND_NONE || (CGContextDrawTiledImage && source->extend == CAIRO_EXTEND_REPEAT)))
+	       (source->extend == CAIRO_EXTEND_NONE || (CGContextDrawTiledImagePtr && source->extend == CAIRO_EXTEND_REPEAT)))
     {
 	    cairo_surface_pattern_t *spat = (cairo_surface_pattern_t *) source;
 	    cairo_surface_t *pat_surf = spat->surface;
@@ -1298,7 +1313,7 @@ _cairo_quartz_surface_paint (void *abstr
 	if (action == DO_IMAGE)
 	    CGContextDrawImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
 	else
-	    CGContextDrawTiledImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
+	    CGContextDrawTiledImagePtr (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
 	CGContextRestoreGState (surface->cgContext);
     } else if (action != DO_NOTHING) {
 	rv = CAIRO_INT_STATUS_UNSUPPORTED;
@@ -1388,7 +1403,7 @@ _cairo_quartz_surface_fill (void *abstra
 	if (action == DO_IMAGE)
 	    CGContextDrawImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
 	else
-	    CGContextDrawTiledImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
+	    CGContextDrawTiledImagePtr (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
     } else if (action != DO_NOTHING) {
 	rv = CAIRO_INT_STATUS_UNSUPPORTED;
     }
@@ -1496,7 +1511,7 @@ _cairo_quartz_surface_stroke (void *abst
 	if (action == DO_IMAGE)
 	    CGContextDrawImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
 	else
-	    CGContextDrawTiledImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
+	    CGContextDrawTiledImagePtr (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
     } else if (action == DO_SHADING) {
 	CGContextReplacePathWithStrokedPath (surface->cgContext);
 	CGContextClip (surface->cgContext);
@@ -1655,7 +1670,7 @@ _cairo_quartz_surface_show_glyphs (void 
 	if (action == DO_IMAGE)
 	    CGContextDrawImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
 	else
-	    CGContextDrawTiledImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
+	    CGContextDrawTiledImagePtr (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
     } else if (action == DO_SHADING) {
 	CGContextDrawShading (surface->cgContext, surface->sourceShading);
     }
@@ -1710,7 +1725,7 @@ _cairo_quartz_surface_mask_with_surface 
 
     rect = CGRectMake (-mask->base.matrix.x0, -mask->base.matrix.y0, extents.width, extents.height);
     CGContextSaveGState (surface->cgContext);
-    CGContextClipToMask (surface->cgContext, rect, img);
+    CGContextClipToMaskPtr (surface->cgContext, rect, img);
     status = _cairo_quartz_surface_paint (surface, op, source);
 
     CGContextRestoreGState (surface->cgContext);
@@ -1739,7 +1754,7 @@ _cairo_quartz_surface_mask (void *abstra
 	cairo_solid_pattern_t *solid_mask = (cairo_solid_pattern_t *) mask;
 
 	CGContextSetAlpha (surface->cgContext, solid_mask->color.alpha);
-    } else if (CGContextClipToMask &&
+    } else if (CGContextClipToMaskPtr &&
                mask->type == CAIRO_PATTERN_TYPE_SURFACE &&
 	       mask->extend == CAIRO_EXTEND_NONE) {
 	return _cairo_quartz_surface_mask_with_surface (surface, op, source, (cairo_surface_pattern_t *) mask);
@@ -1862,6 +1877,8 @@ _cairo_quartz_surface_create_internal (C
 					unsigned int height)
 {
     cairo_quartz_surface_t *surface;
+
+    quartz_ensure_symbols();
 
     /* Init the base surface */
     surface = malloc(sizeof(cairo_quartz_surface_t));
