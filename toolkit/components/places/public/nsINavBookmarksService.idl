/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Places.
 *
 * The Initial Developer of the Original Code is
 * Google Inc.
 * Portions created by the Initial Developer are Copyright (C) 2005
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Brian Ryner <bryner@brianryner.com> (original author)
 *   Joe Hughes <joe@retrovirus.com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

#include "nsISupports.idl"

%{C++
#include "nsTArray.h"
#include "prtypes.h"
%}

interface nsIFile;
interface nsIURI;
interface nsITransaction;

[ptr] native PRInt64Array(nsTArray<PRInt64>);

/**
 * Observer for bookmark changes.
 */

[scriptable, uuid(582af67b-cde2-4dc2-9ef5-9eb79e224135)]
interface nsINavBookmarkObserver : nsISupports
{
  /**
   * Notify this observer that a batch transaction has started.
   * Other notifications will be sent during the batch change,
   * but the observer is guaranteed that onEndUpdateBatch() will be called
   * at the completion of changes.
   */
  void onBeginUpdateBatch();

  /**
   * Notify this observer that a batch transaction has ended.
   */
  void onEndUpdateBatch();

  /**
   * Notify this observer that the bookmark was added.  Called after the actual
   * add took place. The rest of the bookmarks will be shifted down, but no
   * additional notifications will be sent.
   *
   * @param aBookmarkId
   *        The id of the bookmark that was added.
   * @param aFolder
   *        The folder that the item was added to.
   * @param aIndex
   *        The item's index in the folder.
   */
  void onItemAdded(in long long aBookmarkId, in long long aFolder,
                   in long aIndex);

  /**
   * Notify this observer that the bookmark was removed.  Called after the
   * actual remove took place. The bookmarks following the index will be
   * shifted up, but no additional notifications will be sent.
   *
   * @param aBookmarkId
   *        The id of the bookmark that was removed.
   * @param aFolder
   *        The folder that the item was removed from.
   * @param aIndex
   *        The bookmark's index in the folder.
   */
  void onItemRemoved(in long long aBookmarkId, in long long aFolder,
                     in long aIndex);

  /**
   * Notify this observer that a bookmark's information has changed.  This
   * will be called whenever any attributes like "title" are changed.
   * 
   * @param aBookmarkId
   *        The id of the bookmark that was changed.
   * @param aProperty
   *        The property which changed.
   * @param aIsAnnotationProperty
   *        Is aProperty the name of an item annotation
   *
   * property = "cleartime": (history was deleted, there is no last visit date):
   *                         value = none
   * property = "title": value = new title
   * property = "favicon": value = new "moz-anno" URL of favicon image
   * property = "uri": value = new uri spec
   * aIsAnnotationProperty = true: value = empty string
   */
  void onItemChanged(in long long aBookmarkId, in ACString aProperty,
                     in boolean aIsAnnotationProperty,
                     in AUTF8String aValue);

  /**
   * Notify that the item was visited. Normally in bookmarks we use the last
   * visit date, and normally the time will be a new visit that will be more
   * recent, but this is not guaranteed. You should check to see if it's
   * actually more recent before using this new time.
   *
   * @param aBookmarkId
   *        The id of the bookmark that was visited.
   * @see onItemChanged property = "cleartime" for when all visit dates are
   * deleted for the URI.
   */
  void onItemVisited(in long long aBookmarkId, in long long aVisitID,
                     in PRTime time);

  /**
   * Notify this observer that a bookmark folder has been added.
   *  @param aFolder
   *         The id of the folder that was added.
   *  @param aParent
   *         The id of the folder's parent.
   *  @param aIndex
   *         The folder's index inside its parent.
   */
  void onFolderAdded(in long long aFolder, in long long aParent,
                     in long aIndex);

  /**
   * Notify this observer that a bookmark folder has been removed.
   *  @param aFolder
   *         The id of the folder that was removed.
   *  @param aParent
   *         The id of the folder's old parent.
   *  @param aIndex
   *         The folder's old index in its parent.
   */
  void onFolderRemoved(in long long aFolder, in long long aParent,
                       in long aIndex);

  /**
   * Notify this observer that a bookmark folder has been moved.
   *  @param aFolder
   *         The id of the folder that was moved.
   *  @param aOldParent
   *         The id of the folder's old parent.
   *  @param aOldIndex
   *         The folder's old index inside oldParent.
   *  @param aNewParent
   *         The id of the folder's new parent.
   *  @param aNewIndex
   *         The folder's index inside newParent.
   */
  void onFolderMoved(in long long aFolder,
                     in long long aOldParent, in long aOldIndex,
                     in long long aNewParent, in long aNewIndex);

  /**
   * Notify this observer that a bookmark folder's information has changed.
   * This will be called whenever any attributes like "title" are changed.
   *  @param aFolder
   *         The id of the folder that was changed.
   *  @param aProperty
   *         The property that was changed.
   */
  void onFolderChanged(in long long aFolder, in ACString aProperty);

  /**
   * Notify this observer that a separator has been added.
   *  @param aParent
   *         The id of the separator's parent.
   *  @param aIndex
   *         The separator's index inside its parent.
   */
  void onSeparatorAdded(in long long aParent, in long aIndex);

  /**
   * Notify this observer that a separator has been removed.
   *  @param aParent
   *         The id of the separator's parent.
   *  @param aIndex
   *         The separator's old index in its parent.
   */
  void onSeparatorRemoved(in long long  aParent, in long aIndex);
};

/**
 * The BookmarksService interface provides methods for managing bookmarked
 * history items.  Bookmarks consist of a set of user-customizable
 * folders.  A URI in history can be contained in one or more such folders.
 */

[scriptable, uuid(7c2f2c2a-fccb-11db-8314-0800200c9a66)]
interface nsINavBookmarksService : nsISupports
{
  /**
   * The folder ID of the Places root.
   */
  readonly attribute PRInt64 placesRoot;

  /**
   * The folder ID of the bookmarks root.
   */
  readonly attribute PRInt64 bookmarksRoot;

  /**
   * The folder ID of the top-level folders that contain the tag "folders".
   *
   * NOTE: This isn't wired up yet, so don't try to use it for anything until
   *       bug 329961 is marked resolved.
   */
  readonly attribute PRInt64 tagRoot;

  /**
   * The folder ID of the personal toolbar.
   */
  attribute PRInt64 toolbarFolder;

  /**
   * This value should be used for APIs that allow passing in an index
   * where an index is not known, or not required to be specified.
   * e.g.: When appending an item to a folder.
   */
  const short DEFAULT_INDEX = -1;

  const short TYPE_BOOKMARK = 1;
  const short TYPE_FOLDER = 2;
  const short TYPE_SEPARATOR = 3;

  /**
   * Inserts a child item into the given folder. If this item already exists in
   * the given folder, it will be moved to the new position.
   *  @param folder     The id of the parent folder
   *  @param item       The URI to insert
   *  @param index      The index to insert at, or -1 to append
   *  @returns          The ID of the newly-created bookmark
   */
  PRInt64 insertItem(in PRInt64 folder, in nsIURI item, in PRInt32 index);

  /**
   * Removes a child item. Used to delete a bookmark or separator.
   *  @param bookmarkId  The child item to remove
   */
  void removeItem(in PRInt64 bookmarkId);

  /**
   * Creates a new child folder and inserts it under the given parent.
   *  @param parent     The id of the parent folder
   *  @param name       The name of the new folder
   *  @param index      The index to insert at, or -1 to append
   *  @returns the ID of the newly-inserted folder
   */
  PRInt64 createFolder(in PRInt64 parent, in AString name, in PRInt32 index);

  /**
   * Wrapper for container services.  Creates a folder under the given
   * parent and sets the container type. Containers are wrappers around
   * read-only folders, with a specific type.
   *
   *  @param parent     The id of the parent folder
   *  @param name       The name of the new folder
   *  @param type       The type of container to insert
   *  @param index      The index to insert at, or -1 to append
   *  @returns the ID of the newly-inserted folder
   */
  PRInt64 createContainer(in PRInt64 parent, in AString name,
                          in AString type, in PRInt32 index);

  /**
   * Removes a folder from the bookmarks tree.
   *  @param folder     The id of the folder to remove.
   */
  void removeFolder(in PRInt64 folder);

  /**
   * Gets an undo-able transaction for removing a folder from the bookmarks
   * tree. 
   *  @param folder     The id of the folder to remove.
   *  @returns An object implementing nsITransaction that can be used to undo 
   *           or redo the action. 
   *
   * This method exists because complex delete->undo operations rely on 
   * recreated folders to have the same ID they had before they were deleted, 
   * so that any other items deleted in different transactions can be 
   * re-inserted correctly. This provides a safe encapsulation of this 
   * functionality without exposing the ability to recreate folders with 
   * specific IDs (potentially dangerous if abused by other code!) in the
   * public API.
   */
  nsITransaction getRemoveFolderTransaction(in PRInt64 folder);

  /**
   * Convenience function for container services.  Removes
   * all children of the given folder.
   *  @param folder     The id of the folder to remove children from.
   */
  void removeFolderChildren(in PRInt64 folder);

  /**
   * Moves a folder to a different container, preserving its contents.
   *  @param folder      The folder to move
   *  @param newParent   The id of the folder's new parent
   *  @param index       The folder's index under newParent, or -1 to append
   */
  void moveFolder(in PRInt64 folder, in PRInt64 newParent, in PRInt32 index);

  /**
   * Returns the ID of a child folder with the given name. This does not
   * recurse, you have to give it an immediate sibling of the given folder.
   * If the given subfolder doesn't exist, it will return 0.
   *  @param folder    Parent folder whose children we will search
   *  @param subFolder Name of the folder to search for in folder
   */
  PRInt64 getChildFolder(in PRInt64 folder, in AString subFolder);

  /**
   * Inserts a bookmark separator into the given folder at the given index.
   * The separator can be removed using removeChildAt().
   *  @param folder    Parent folder of the separator
   *  @param index     The separator's index under folder, or -1 to append
   */
  void insertSeparator(in PRInt64 folder, in PRInt32 index);

  /**
   * Removes any type of child (item, folder, or separator) at the given index.
   *  @param folder    The folder to remove a child from
   *  @param index     The index of the child to remove
   */
  void removeChildAt(in PRInt64 folder, in PRInt32 index);

  /**
   * Set the title for a bookmark.
   *  @param id    The id of the item whose title should be updated 
   *  @param title The new title for the bookmark. 
   */
  void setItemTitle(in PRInt64 id, in AString title);

  /**
   * Get the title for the bookmark.
   *
   * If no item title is available it will return a void string (null in JS).
   *
   *  @param id    The id of the item whose title should be retrieved
   *  @returns     The title of the item.
   */
  AString getItemTitle(in PRInt64 id);

  /**
   * Get the URI for a bookmark item.
   */
  nsIURI getBookmarkURI(in PRInt64 id);

  /**
   * Get the index for an item.
   */
  PRInt32 getItemIndex(in PRInt64 id);

  /**
   * Set the title for a bookmark folder.
   *  @param folder     The folder whose title should be set
   *  @param title      The new title for the folder
   */
  void setFolderTitle(in PRInt64 folder, in AString title);

  /**
   * Get the title for a bookmark folder.  Throws an invalid argument
   * exception if it can't find a folder with the given ID.
   *
   *  @param folder     The folder whose title should be retrieved
   *  @returns          The title for the folder
   */
  AString getFolderTitle(in PRInt64 folder);

  /**
   * Get the place: url for a bookmark folder. You can use this value to
   * get/set the icon for a folder or to associate other data with it using
   * the annotation service. Its important that you use this function instead
   * of just serializing the query/options for a given folder because you
   * may have different options or query parameters. This function will give
   * the canonical value.
   * @param folder      The folder whose URI should be retrieved
   * @returns           The URI for the folder
   */
  nsIURI getFolderURI(in PRInt64 folder);

  /**
   * Get an item's type (bookmark, separator, folder).
   * The type is one of the TYPE_* constants defined above.
   */
  long getItemType(in PRInt64 itemId);

  /**
   * Get the place: url for an item (bookmark, separator).
   * This can be used for annotating bookmark items.
   * NOTE: this is not currently supported in the query framework.
   */
  nsIURI getItemURI(in PRInt64 itemId);

  /**
   * Checks whether a folder has read-only children.  This property is
   * defined by the nsIBookmarsContainer for the folder, if one exists.
   * If this is set to true, UI should not allow the user to add, remove,
   * or reorder children in this folder.  The default for all folders is false.
   */
  boolean getFolderReadonly(in PRInt64 folder);

  /**
   * Returns true if the given URI is in any bookmark folder. If you want the
   * results to be redirect-aware, use getBookmarkedURIFor()
   */
  boolean isBookmarked(in nsIURI uri);

  /**
   * Used to see if the given URI is bookmarked, or any page that redirected to
   * it is bookmarked. For example, if I bookmark "mozilla.org" by manually
   * typing it in, and follow the bookmark, I will get redirected to
   * "www.mozilla.org". Logically, this new page is also bookmarked. This
   * function, if given "www.mozilla.org", will return the URI of the bookmark,
   * in this case "mozilla.org".
   *
   * If there is no bookmarked page found, it will return NULL.
   */
  nsIURI getBookmarkedURIFor(in nsIURI uri);

  /**
   * Change the bookmarked URI for a bookmark.
   * This changes which "place" the bookmark points at,
   * which means all annotations, etc are carried along.
   */
  void changeBookmarkURI(in PRInt64 id, in nsIURI newURI);

  /**
   * Get the parent folder's id for an item.
   */
  PRInt64 getFolderIdForItem(in PRInt64 id);

  /**
   * Returns the list of bookmark ids that contain the given URI.
   */
  void getBookmarkIdsForURI(in nsIURI uri, out PRUint32 count,
                          [array, retval, size_is(count)] out PRInt64 bookmarks);

  /**
   * TArray version of getBookmarksIdForURI for ease of use in C++ code.
   * Pass in a reference to a TArray; it will get cleared and filled with
   * the resulting list of folder IDs.
   */
  [noscript] void getBookmarkIdsForURITArray(in nsIURI aURI,
                                           in PRInt64Array aResult);

  /**
   * Associates the given keyword with the given bookmark.
   *
   * Use an empty keyword to clear the keyword associated with the URI.
   * In both of these cases, succeeds but does nothing if the URL/keyword is not found.
   */
  void setKeywordForBookmark(in PRInt64 bookmarkId, in AString keyword);

  /**
   * Retrieves the keyword for the given URI. Will be void string
   * (null in JS) if no such keyword is found.
   */
  AString getKeywordForURI(in nsIURI uri);

  /**
   * Retrieves the keyword for the given bookmark. Will be void string
   * (null in JS) if no such keyword is found.
   */
  AString getKeywordForBookmark(in PRInt64 bookmarkId);

  /**
   * Returns the URI associated with the given keyword. Empty if no such
   * keyword is found.
   */
  nsIURI getURIForKeyword(in AString keyword);

  /**
   * Adds a bookmark observer. If ownsWeak is false, the bookmark service will
   * keep an owning reference to the observer.  If ownsWeak is true, then
   * aObserver must implement nsISupportsWeakReference, and the bookmark
   * service will keep a weak reference to the observer.
   */
  void addObserver(in nsINavBookmarkObserver observer, in boolean ownsWeak);

  /**
   * Removes a bookmark observer.
   */
  void removeObserver(in nsINavBookmarkObserver observer);

  /**
   * Causes observers to be notified of a beginUpdateBatch when a lot of things
   * are about to change. Calls can be nested, observers will only be
   * notified when all batches begin/end.
   *
   * It is EXTREMELY IMPORTANT that you call EndUpdateBatch for each call to
   * beginUpdateBatch. If you don't do this, certain parts of the UI will not
   * get updated and any changes to bookmarks will not get written to disk.
   * From C++ code inside the places component, use nsBookmarksUpdateBatcher
   * defined in nsNavBookmarks.h to scope batches. For JS or from other
   * components, just please be very careful to close the batch, especially
   * when encountering an error and returning early.
   */
  void beginUpdateBatch();

  /**
   * Causes observers to be notified of an endUpdateBatch when a batch is
   * done changing. Should match beginUpdateBatch or bad things will happen.
   */
  void endUpdateBatch();
};
